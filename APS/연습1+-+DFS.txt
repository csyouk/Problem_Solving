

//////  깊이 우선 탐색 
// 입력 데이터
// 1 2 1 3 2 4 2 5 4 6 5 6 6 7 3 7


#include <iostream>
using namespace std;

//int G[8][4] = {
//    { 0, 0, 0, 0 },
//    { 2, 2, 3, 0 },   // 정점 1의 인접정점의 개수와 인접정점들
//    { 3, 1, 4, 5 },   // 정점 2의 인접정점의 개수와 인접정점들
//    { 2, 1, 7, 0 },   // 정점 3의 인접정점의 개수와 인접정점들
//    { 2, 2, 6, 0 },   // 정점 4의 인접정점의 개수와 인접정점들
//    { 2, 2, 6, 0 },   // 정점 5의 인접정점의 개수와 인접정점들
//    { 3, 4, 5, 7 },   // 정점 6의 인접정점의 개수와 인접정점들
//    { 2, 3, 6, 0 } }; // 정점 7의 인접정점의 개수와 인접정점들
int G[8][4];

int visited[8] = { 0 };

int stack[10];
int top = -1;

//재귀
void DFSr(int v)
{
	visited[v] = 1;
	printf("%d ", v);

	for (int i = 1; i <= G[v][0]; i++)
		if (!visited[G[v][i]])
			DFSr(G[v][i]);
}


void DFS(int V)
{
	stack[++top] = V;

	while (top != -1)
	{
		int v = stack[top--];

		if (!visited[v])
		{
			visited[v] = 1;
			cout << v << " ";

			for (int i = G[v][0]; i > 0; i--)
				if (!visited[G[v][i]])
					stack[++top] = G[v][i];

		}
	}
}


void main(void)
{
	int u, v;
	for (int i = 0; i < 8; i++)
	{
		cin >> u >> v;
		G[u][++G[u][0]] = v;
		G[v][++G[v][0]] = u;
	}

	DFS(1);
}

